#ifndef EvolvedPlus_Messages_Pool_H
#define EvolvedPlus_Messages_Pool_H

#include <map>
#include <vector>
#include <typeinfo>
#include <string>

#include "MessageComparator.h"

namespace EvolvedPlus {

	namespace Messages {

		/**
		Forward declarations.
		*/
		class CMessage;

		/**
		Messages are created and destroyed each frame, and there are potentially big
		amounts of messages being sent per frame. Since messages are used throughout the
		execution, we're creating and destroying memory very quickly and multiple times.
		Trying to prevent the possible overhead of creating and destroying, and trying
		to avoid the possible fragmentation generated by that, we manage messages through
		an object pool.
		A given number of messages of each type are instantiated during initialization and
		exist during the execution of the game. When some component needs to send a message,
		it will ask the pool to provide one; when it's not useful anymore, the message is
		returned to the pool for later reuse.
		So, we trade possible fragmentation and creation/deletion performance for an increase
		in memory consumption and supposedly quicker creation/deletion.
		*/
		class CPool {

			/**
			The current and unique instance of the singleton.
			*/
			static CPool *_instance;

			/**
			Basic constructor, private as a part of the singleton pattern.
			*/
			CPool();

			/**
			Basic destructor.
			We can only destruct it from inside, so it's private.
			*/
			~CPool();

			/**
			In order to prevent accidental (or intentional) copying of the singleton instance,
			we declare the copy constructor as private so a compile-time error is shown.
			*/
			CPool(const CPool &factory);

			/**
			In order to prevent accidental (or intentional) copying of the singleton instance,
			we declare the assignment operator as private so a compile-time error is shown.
			*/
			CPool &operator=(const CPool &factory);

			/**
			Alias for a function pointer which creates an empty message.
			Those functions will be static functions which exist within the messages.
			*/
			typedef CMessage *(*MessageInstantiator)();

			/**
			Alias for our structure to store message constructors.
			*/
			typedef std::map<std::string, MessageInstantiator> TMessageConstructors;

			/**
			Structure to store message names and functions to create each one of them.
			*/
			TMessageConstructors _messageConstructors;

			/**
			Alias for a list of messages.
			*/
			typedef std::vector<CMessage *> TMessageList;

			/**
			Alias for each entry of our built messages.
			*/
			struct CMessageEntry {
				/**
				List of built messages, awaiting to be used.
				*/
				TMessageList ready;

				/**
				List of messages currently in use.
				*/
				TMessageList inUse;
			};

			/**
			Alias for a map which stores built messages which are ready and being used, by type.
			*/
			typedef std::map<const std::type_info *, CMessageEntry, CMessageComparator> TMessages;

			/**
			Map which stores built messages, indexed by message type, both ready and in use.
			*/
			TMessages _messages;

			/**
			Alias for a map which stores message types and the names used to store their instantiators.
			*/
			typedef std::map<const std::type_info *, std::string, CMessageComparator> TMessageNames;

			/**
			Map which links message types with the names used to store instantiators.
			Used when we've run out of instances.
			*/
			TMessageNames _messageNames;

		public:
			/**
			Initializes the pool with some messages for each type.
			*/
			void initialize();

			/**
			When the singleton won't be used anymore, we can call this method to destroy the
			current instance. This is the only way of destroying it and not calling it would
			leak it.
			*/
			static void release();

			/**
			Gets the instance of this factory.
			It's a singleton, and by returning instead of a pointer we are subtly declaring
			three characteristics:
			    - It won't be NULL: if it was a pointer, and even if we did our work
				  initializing it, it could be NULL conceptually.
				- It can't be changed: a pointer could be pointed somewhere else.
				- It can't be deleted from outside code: pointers could.
			*/
			static CPool &getInstance();

			/**
			Gets an instance of an object, by type, ready to be used.
			Provide message data via its init() method.
			*/
			template <typename T>
			T *obtainMessage() {
				// get map's key
				const std::type_info *type = &typeid(T);

				// is there any message of that type in the map?
				TMessages::iterator itMessages = _messages.find(type);

				if(itMessages == _messages.end()) {
					return NULL;
				}

				CMessageEntry *entry = &itMessages->second;

				// is there any message ready to be used?
				if(entry->ready.size() == 0) {
					/**
					Pools can have different policies when they run out of instances to provide.
					The simplest one is just to return NULL, which indicates we're out of instances.
					Another one is to have an "overflow buffer". When we're asked for a message and
					we don't have any ready, we check the buffer. If it's got any, we return it; else,
					we create a new instance but keep track that it's not part of the normal pool.
					Periodically, we clean that buffer up (i.e. each second) and have that time window
					to keep up with the high demand.
					Other policy, which is the one we're providing, consists on creating a new instance
					and keeping it for the rest of the execution. It's simpler, but if we had a demand
					peak we'll keep the extra instances even though they might not be used.
					*/
					entry->ready.push_back(_messageConstructors[_messageNames[&typeid(T)]]());
				}

				// extract a message, add it into the inUse list, and return it
				T *message = static_cast<T *>(entry->ready.back());
				entry->ready.pop_back();
				entry->inUse.push_back(message);
				return message;
			}

			/**
			Releases an instance of a message, and returns it to the pool.
			*/
			void releaseMessage(CMessage *message);

			/**
			Adds a message constructor to the pool.
			*/
			void add(const std::string &name, MessageInstantiator instantiator);
		};

	}

}

#endif